# CD-TM-TH-HS-L2-01-测试策略设计文档

<table border="0" bordercolor="#FFFFFF">
  <tr>
    <th><img alt="title pic" src="../../docs/imgs/DevOps流程/DevOps_Gears.png"></th>
    <th><h1 style="font-size:150%">能力项  [测试分层策略]</h1></th>
  </tr>
</table>

# 前言

自动化测试从广义上来说，一切通过工具(程序)的方式来代替或者辅助手工测试的行为都可以成为自动化。从狭义上来说，通过编写脚本的方式，模拟手工测试的过程，从而替代人工对系统的功能进行验证。

为了提高传统自动化测试的效率，项目组采用了分层自动化测试的方法。通过不同层次的自动化测试和策略，提升测试用例的执行速度，加快自动化测试发现问题的定位，增加自动化测试的覆盖率。

# 分层测试架构前言

<img alt="Testing Process" src="../../docs/imgs/DevOps流程/Testing_Process.png">

根据测试分层的策略，在测试环境中提供四种测试服务：

- 代码静态扫描：通过静态扫描的方式对代码的规范性和安全性进行测试并产生测试报告

- 单元测试：通过单元测试对代码库里的某个单元（被测试的主体）按照预期工作进行测试并生成单元测试报告和覆盖率

- API接口测试：通过API接口测试在服务调用时发送正确的请求，检测服务API是否正确地解析响应，生成API测试覆盖率

- 真机界面测试：通过真机UI 测试检测应用中的用户界面是否如预期工作。比如，用户的输入是否触发正确的动作，数据是否正确展示给用户，UI 的状态是否发生正确变化等

# 代码静态扫描

静态代码扫描通过指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性，通过检查项目的源码，从源码中找出代码存在的缺陷：潜在的bug，未使用的代码，复杂的表达式，重复的代码等。

静态代码扫描的优点包括帮助程序开发人员自动执行静态代码分析，快速定位代码隐藏错误和缺陷；帮助代码设计人员更专注于分析和解决代码设计缺陷；显著减少在代码逐行检查上花费的时间，提高软件可靠性并节省软件开发和测试成本。

静态检查可以检测的问题包括：

- 变量未初始化；

- 空指针引用（野指针）；

- 数据类型不匹配；

- 返回局部变量；

- 数组越界；

- 内存泄漏等…

Sonar (SonarQube)是一个开源平台，用于管理源代码的质量。 Sonar 不只是一个质量数据报告工具，更是代码质量管理平台。 支持java, C#, C/C++, PL/SQL, Cobol, JavaScrip, Groovy 等等二十几种编程语言的代码质量管理与检测。 Sonar可以从以下七个维度检测代码质量，而作为开发人员至少需要处理前5种代码质量问题。

- 不遵循代码标准 sonar可以通过代码规则检测工具规范代码编写。

- 潜在的缺陷 sonar可以通过代码规则检测工具检测出潜在的缺陷。

- 糟糕的复杂度分布 文件、类、方法等，如果复杂度过高将难以改变，这会使得开发人员 难以理解它们, 且如果没有自动化的单元测试，对于程序中的任何组件的改变都将可能导致需要全面的回归测试。

- 重复 显然程序中包含大量复制粘贴的代码是质量低下的，sonar可以展示 源码中重复严重的地方。

- 注释不足或者过多 没有注释将使代码可读性变差，特别是当不可避免地出现人员变动 时，程序的可读性将大幅下降 而过多的注释又会使得开发人员将精力过多地花费在阅读注释上，亦违背初衷。

- 缺乏单元测试 sonar可以很方便地统计并展示单元测试覆盖率。

- 糟糕的设计 通过sonar可以找出循环，展示包与包、类与类之间的相互依赖关系，可以检测自定义的架构规则 通过sonar可以管理第三方的jar包，可以利用LCOM4检测单个任务规则的应用情况， 检测耦合。

> 本项目的规则放在[Gitlab Address]/bjyd/[project name]/tree/dev/test/sonarpolicy/中。

# 单元测试

单元测试是对软件中的最小可测试单元进行检查和验证。具体的说就是开发者编写的一小段代码，用于检验被测代码的一个很小的、很明确的功能是否正确。通常而言，一个单元测试是用于判断某个特定条件（或者场景）下某个特定函数的行为。

单元测试组合的基石。单元测试保证了代码库里的某个单元（被测试的主体）能按照预期那样工作。单元测试在测试组合里测试的范围是最窄的。它的数量在测试组合中应该远远多于其他类型的测试。

单元测试有个好处，就是可以为所有的产品代码类写单元测试，而不需要管它们的功能如何，或者它们在内部结构中属于哪个层次。可以对 controller 进行单元测试，也可以用同样的方式对 repository、领域类或者文件读写类进行单元测试。最佳实践可以从坚持一个实现类就有一个测试类的法则开始。

一个单元测试类至少应该测试这个类的公共接口。私有方法不能直接测试的原因是不能从测试类直接调用它们。受保护的和包私有的方法可以被测试类直接调用（如果测试类和生产代码类的包结构是一样的），但是测试这些方法可能就过于复杂了。

编写单元测试有一条细则：它们应该保证你代码所有的路径都被测试到（包括正常路径和边缘路径）。同时它们不应该和代码的实现有太紧密的耦合。

一个好的测试结构（不局限于单元测试）是这样的：

- 准备测试数据

- 调用被测方法

- 断言返回的是期待的结果

为了做细粒度的测试，需要解决单元测试的外部依赖。系统和模块之间的依赖可以通过Mock框架(Mockito/EasyMock)解耦，同时可以结合h2database解决对数据库的依赖，使得测试用例尽可能做到可以随时随地运行。这一层发现并解决问题付出的成本相对来说最低，自动化用例的维护成本也不高，总的来说自动化测试的投入产出比最高。单元测试的责任主体一般来说是开发人员，写单元测试也是开发人员对自己的代码进行检查的一个过程。

项目写单元测试用的是JUnit，Java 实际意义上的标准测试框架。使用打桩隔离不同的程序类，允许在测试里重新定义调用后产生的响应。打桩能让测试更简单，更可预测，更容易组织测试数据。

> 项目中后端单元测试代码放在[Gitlab Address]/bjyd/[Project Name]/tree/dev/src/backend/src/test中。

# API接口测试

API接口测试是在单元测试的基础上，测试在将所有的软件服务按照接口说明的要求检查是否达到或实现相应技术指标及要求的活动。也就是说，在API接口测试之前，单元测试应该已经完成。这一点很重要，因为如果不经过单元测试，那么API接口测试的效果将会受到很大影响，并且会大幅增加软件单元代码纠错的代价。

现代的应用服务架构会将系统拆分成多个更小的服务，常常意味着这些服务之间需要通过确定的（最好是定义明确的，但有时候会有变动演进）接口通信。

不同应用间的接口可能形态各异，或基于不同的技术栈。常见的有：

- 基于 HTTPS 使用 JSON 交互的 REST 接口

- 基于类似gRPC的 RPC（Remote Procedure Call，远程进程调用）接口

- 使用队列构建的事件驱动架构

对于任意一个接口，一定会涉及两个实体：提供方和消费方。提供方为消费方提供数据。消费方处理来自提供方的数据。在 REST 世界里，提供方为所有要暴露的 API 创建一个 REST API；消费方则调用这些 API 来获取数据，或进一步触发其他的服务。而在一个由异步、事件驱动的世界，提供方（通常被称为发布者）发布数据到一个队列中；消费方（通常被称为订阅者）订阅这些队列，读取并处理相关数据。

自动化API接口测试保证了消费方和提供方实现的时候依然遵循定义好的API规范。这种测试提供了一个良好的回归测试组合，保证API接口的变更能被及早发现。

在项目的敏捷组织中，采用接口规范标准Swgger来定义接口并和代码同步。项目的接口定义文件swagger.yaml放置在[Gitlab Address]/bjyd/[Project Name]/tree/dev/docs中。

测试团队或者开发团队都可以编写接口测试用例，检查接口是不是返回了预期的所有数据。会以代码的方式发布这些测试用例到代码仓库中，从而让使用者可以轻松获取到这些测试并执行。前后端开发人员都可以一边运行API 测试一边开发他们的代码了。一旦所有测试通过，立刻可以知道已经实现了所有API接口消费方想要的东西。

Tarven是一个pytest的插件，用于RESTful API自动化测试的命令行工具、Python库和Pytest插件，具有简单灵活的基于YAML的语法。并且可以针对复杂测试进行高度自定义。 Tavern支持测试RESTful API以及基于MQTT的API。

使用Tavern的最佳方式是利用pytest。 Tavern附带一个pytest插件，安装pytest和Tavern，在.tavern.yaml文件中编写的测试并运行pytest。可以访问所有pytest生态系统，并允许执行各种操作，例如针对测试服务器运行测试并报告问题或生成HTML报告。

项目的API测试脚本在[Gitlab Address]/bjyd/[Project Name]/tree/dev/test/apitest/tavern目录下。

# UI测试

UI 测试测的是应用中的用户界面是否如预期工作。比如，用户的输入需要触发正确的动作，数据需要能展示给用户看，UI 的状态需要发生正确变化等。因为UI层是产品最终呈现给用户的东西。所以在做好上面两层的测试覆盖之后，测试人员可以投入更多的精力到UI层的测试上。正是因为测试人员会在UI层投入较大精力，有必要通过自动化来帮助解放部分重复劳动力。

根据项目的UI层自动化实践，提出UI层自动化覆盖的原则：

- 能在底层做自动化覆盖，就尽量不在UI层做自动化覆盖

- 只做最核心的功能的自动化覆盖，脚本可维护性尽可能提高

对于传统的网页应用，UI 测试可以用Selenium这一类工具完成。手机端应用多采用Appium框架。对于界面而言，UI可以围绕这几个部分进行测试：行为，布局，可用性，以及测试设计的一致性。

测试用户界面的行为非常简单。点击一下，输入数据，然后看到用户界面状态如实变更。现代的单页应用框架（以react, vue.js, Angular等为代表）通常都会提供一些工具或组件，帮助从很低的测试层级（单元测试）对界面交互进行测试。如果没有使用任何框架，只使用纯JavaScript，也有常规的试工具（如Jasmine或Mocha等）可供选择。

UI层的自动化测试是由测试人员负责，在覆盖了核心业务核心场景之后，不应该在这层的自动化覆盖上投入太多的精力和资源。就算在一定程度上提高了脚本的可维护性，可是毕竟自动化测试最怕的就是变化，而UI界面是变化频率最高的一层，所以需要投入精力维护变化的脚本成为界面测试提升覆盖率的瓶颈。

Appium 是一个 C/S 架构的，支持 Android/iOS Native, Hybrid 和 Mobile Web Apps 的测试框架，与测试程序通过 Selenum Webdriver 协议通讯。Webdriver 的好处是通过 HTTP RPC 的方式调用 Server 上的过程，编写测试脚本不受语言的限制，无论是 Python, Java, NodeJS 均可以方便的编写测试。项目中使用Java进行编程。

Appium 实际上就是一个测试工具的统一调度软件，将不同的非侵入式测试工具整合在一起，对外提供统一的 API。在 Android 2.3 以前的版本，Appium 会调用 Selendroid ，之后的版本会直接使用 UIAutomator，iOS 下使用 UIAutomation。Appium 还支持 FirefoxOS 的 UI 测试。

项目的API测试脚本在[Gitlab Address]/bjyd/[Project Name]/tree/dev/test/i-ATF目录下。

# 整洁的测试代码

和写代码一样，良好整洁的测试代码同样需要悉心编写。项目编写测试代码建议遵守以下原则：

- 测试代码跟生产代码一样重要。要对它们赋予同等的关注和精力。“**这只是测试代码**”不能成为写出邋遢代码的借口

- 一次测试只测试一个分支。这能帮测试用例保持短小，容易理解

- “arrange, act, assert”或者“given, when, then”等口诀有助于编写结构良好的测试

- 可读性很重要。不要过于追求 DRY。如果能提高可读性，重复有时候也是可以接受的。尝试在DRY 和 DAMP之间寻找好平衡

- 如果对于重复有疑惑，试试用Rule of Three法则来决定是不是要重构。重构之前先试用一下